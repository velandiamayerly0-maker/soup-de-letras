<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sopa de letras del INVIMA, MINTIC E ICA</title>
    <style>
        /* Reset y estilos base */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f5f5f5; /* Gris claro neutro */
            color: #333;
            line-height: 1.6;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            min-height: 100vh;
        }

        h1 {
            text-align: center;
            color: #2c3e50; /* Azul oscuro suave */
            margin-bottom: 20px;
            font-size: 1.8em;
            text-shadow: 0 1px 2px rgba(0,0,0,0.1);
        }

        #game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            max-width: 100%;
            width: 100%;
        }

        #word-list {
            margin-bottom: 20px;
            text-align: center;
            background: #fff;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            width: 100%;
            max-width: 600px;
        }

        #word-list h2 {
            color: #34495e;
            margin-bottom: 10px;
            font-size: 1.2em;
        }

        #words {
            list-style: none;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
        }

        #words li {
            background: #ecf0f1;
            padding: 5px 10px;
            border-radius: 5px;
            font-weight: bold;
            color: #2c3e50;
            transition: all 0.3s ease;
            border: 2px solid transparent;
        }

        #words li.found {
            background: #3498db; /* Azul suave */
            color: white;
            text-decoration: line-through;
        }

        #grid-container {
            margin-bottom: 20px;
            background: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        #grid {
            display: grid;
            grid-template-columns: repeat(20, 1fr);
            grid-template-rows: repeat(20, 1fr);
            gap: 1px;
            background: #bdc3c7; /* Gris medio */
            border-radius: 5px;
            overflow: hidden;
            touch-action: none; /* Para mejor manejo táctil */
        }

        .cell {
            width: 25px;
            height: 25px;
            background: #fff;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            color: #2c3e50;
            cursor: pointer;
            user-select: none;
            transition: all 0.2s ease;
            border: 1px solid #ecf0f1;
            position: relative;
        }

        /* Tamaños responsivos */
        @media (max-width: 768px) {
            .cell {
                width: 20px;
                height: 20px;
                font-size: 10px;
            }
        }

        @media (max-width: 480px) {
            .cell {
                width: 18px;
                height: 18px;
                font-size: 9px;
            }

            h1 {
                font-size: 1.4em;
            }

            #word-list {
                padding: 10px;
            }
        }

        @media (min-width: 1200px) {
            .cell {
                width: 30px;
                height: 30px;
                font-size: 14px;
            }
        }

        /* Estados de selección */
        .cell.selected {
            background: #3498db !important;
            color: white;
        }

        .cell.part-of-word {
            background: #e8f5e8 !important; /* Verde suave para palabras reveladas */
            color: #27ae60;
        }

        .cell:hover {
            background: #ecf0f1;
            transform: scale(1.05);
        }

        /* Controles */
        #controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
            margin-bottom: 20px;
        }

        button {
            background: #3498db;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.3s ease;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        button:hover {
            background: #2980b9;
        }

        button:active {
            transform: translateY(1px);
        }

        @media (max-width: 480px) {
            #controls {
                flex-direction: column;
                align-items: center;
            }

            button {
                width: 100%;
                max-width: 200px;
            }
        }

        /* Mensajes */
        #message {
            text-align: center;
            margin-top: 10px;
            font-weight: bold;
            color: #27ae60;
            min-height: 20px;
        }

        /* Transiciones suaves */
        * {
            transition: all 0.3s ease;
        }
    </style>
</head>
<body>
    <h1>Sopa de letras del INVIMA, MINTIC E ICA</h1>
    <div id="game-container">
        <div id="word-list">
            <h2>Palabras a encontrar:</h2>
            <ul id="words"></ul>
        </div>
        <div id="grid-container">
            <div id="grid"></div>
        </div>
        <div id="controls">
            <button id="hint-btn">Pista</button>
            <button id="give-up-btn">Rendirse</button>
            <button id="reset-btn">Reiniciar</button>
        </div>
        <div id="message"></div>
    </div>

    <script>
        // Configuración del juego
        const GRID_SIZE = 20;
        const WORDS = [
            'SALUDPUBLICA', 'REGULACION', 'VIGILANCIA', 'CONTROL',
            'FITOSANITARIO', 'MINISTERIO', 'AGROPECUARIO', 'EMPRESAS',
            'CONSUMO', 'DESARROLLO'
        ];
        const DIRECTIONS = [
            { dx: 1, dy: 0 },   // Horizontal derecha
            { dx: 0, dy: 1 },   // Vertical abajo
            { dx: 1, dy: 1 },   // Diagonal abajo-derecha
            { dx: -1, dy: 1 },  // Diagonal abajo-izquierda
            { dx: -1, dy: 0 },  // Horizontal izquierda
            { dx: 0, dy: -1 },  // Vertical arriba
            { dx: -1, dy: -1 }, // Diagonal arriba-izquierda
            { dx: 1, dy: -1 }   // Diagonal arriba-derecha
        ];

        // Estado del juego
        let grid = [];
        let wordPositions = {}; // {word: [{x,y}, ...]}
        let foundWords = new Set();
        let isSelecting = false;
        let selection = []; // [{x,y}]
        let currentCell = null;

        // Elementos DOM
        const gridEl = document.getElementById('grid');
        const wordsEl = document.getElementById('words');
        const messageEl = document.getElementById('message');
        const hintBtn = document.getElementById('hint-btn');
        const giveUpBtn = document.getElementById('give-up-btn');
        const resetBtn = document.getElementById('reset-btn');

        // Inicializar juego
        function init() {
            generateGrid();
            renderGrid();
            renderWords();
            setupEventListeners();
            messageEl.textContent = '';
            foundWords.clear();
        }

        // Generar cuadrícula aleatoria
        function generateGrid() {
            grid = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(' '));
            wordPositions = {};

            WORDS.forEach(word => {
                let placed = false;
                let attempts = 0;
                while (!placed && attempts < 100) { // Límite de intentos para evitar bucles infinitos
                    const dir = DIRECTIONS[Math.floor(Math.random() * DIRECTIONS.length)];
                    const len = word.length;
                    const maxX = GRID_SIZE - Math.abs(dir.dx) * (len - 1);
                    const maxY = GRID_SIZE - Math.abs(dir.dy) * (len - 1);
                    const startX = Math.floor(Math.random() * maxX);
                    const startY = Math.floor(Math.random() * maxY);

                    if (canPlaceWord(word, startX, startY, dir)) {
                        placeWord(word, startX, startY, dir);
                        wordPositions[word] = [];
                        for (let i = 0; i < len; i++) {
                            const x = startX + i * dir.dx;
                            const y = startY + i * dir.dy;
                            wordPositions[word].push({ x, y });
                        }
                        placed = true;
                    }
                    attempts++;
                }
                if (!placed) {
                    console.warn(`No se pudo colocar la palabra: ${word}`);
                }
            });

            // Llenar con letras aleatorias
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    if (grid[y][x] === ' ') {
                        grid[y][x] = String.fromCharCode(65 + Math.floor(Math.random() * 26)); // A-Z
                    }
                }
            }
        }

        // Verificar si se puede colocar palabra
        function canPlaceWord(word, startX, startY, dir) {
            const len = word.length;
            for (let i = 0; i < len; i++) {
                const x = startX + i * dir.dx;
                const y = startY + i * dir.dy;
                if (x < 0 || x >= GRID_SIZE || y < 0 || y >= GRID_SIZE) return false;
                if (grid[y][x] !== ' ' && grid[y][x] !== word[i]) return false;
            }
            return true;
        }

        // Colocar palabra en la cuadrícula
        function placeWord(word, startX, startY, dir) {
            const len = word.length;
            for (let i = 0; i < len; i++) {
                const x = startX + i * dir.dx;
                const y = startY + i * dir.dy;
                grid[y][x] = word[i];
            }
        }

        // Renderizar cuadrícula
        function renderGrid() {
            gridEl.innerHTML = '';
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    const cell = document.createElement('div');
                    cell.classList.add('cell');
                    cell.textContent = grid[y][x];
                    cell.dataset.x = x;
                    cell.dataset.y = y;
                    gridEl.appendChild(cell);
                }
            }
        }

        // Renderizar lista de palabras
        function renderWords() {
            wordsEl.innerHTML = '';
            WORDS.forEach(word => {
                const li = document.createElement('li');
                li.textContent = word;
                if (foundWords.has(word)) li.classList.add('found');
                wordsEl.appendChild(li);
            });
        }

        // Configurar event listeners para interacción
        function setupEventListeners() {
            const cells = document.querySelectorAll('.cell');

            // Mouse events para escritorio
            cells.forEach(cell => {
                cell.addEventListener('mousedown', startSelection);
                cell.addEventListener('mouseenter', updateSelection);
                cell.addEventListener('mouseup', endSelection);
            });

            // Touch events para móviles
            gridEl.addEventListener('touchstart', handleTouchStart, { passive: false });
            gridEl.addEventListener('touchmove', handleTouchMove, { passive: false });
            gridEl.addEventListener('touchend', handleTouchEnd, { passive: false });

            // Botones
            hintBtn.addEventListener('click', giveHint);
            giveUpBtn.addEventListener('click', giveUp);
            resetBtn.addEventListener('click', init);
        }

        // Manejo de selección con mouse
        function startSelection(e) {
            e.preventDefault();
            isSelecting = true;
            selection = [];
            const cell = e.target;
            const x = parseInt(cell.dataset.x);
            const y = parseInt(cell.dataset.y);
            addToSelection(x, y);
        }

        function updateSelection(e) {
            if (!isSelecting) return;
            const cell = e.target;
            const x = parseInt(cell.dataset.x);
            const y = parseInt(cell.dataset.y);
            addToSelection(x, y);
        }

        function endSelection(e) {
            if (!isSelecting) return;
            isSelecting = false;
            validateSelection();
            clearSelection();
        }

        // Manejo de touch para móviles
        function handleTouchStart(e) {
            e.preventDefault();
            const touch = e.touches[0];
            const cell = document.elementFromPoint(touch.clientX, touch.clientY);
            if (cell && cell.classList.contains('cell')) {
                isSelecting = true;
                selection = [];
                const x = parseInt(cell.dataset.x);
                const y = parseInt(cell.dataset.y);
                addToSelection(x, y);
            }
        }

        function handleTouchMove(e) {
            if (!isSelecting) return;
            e.preventDefault();
            const touch = e.touches[0];
            const cell = document.elementFromPoint(touch.clientX, touch.clientY);
            if (cell && cell.classList.contains('cell')) {
                const x = parseInt(cell.dataset.x);
                const y = parseInt(cell.dataset.y);
                addToSelection(x, y);
            }
        }

        function handleTouchEnd(e) {
            if (!isSelecting) return;
            e.preventDefault();
            isSelecting = false;
            validateSelection();
            clearSelection();
        }

        // Añadir celda a selección (evitar duplicados)
        function addToSelection(x, y) {
            const pos = { x, y };
            if (!selection.some(p => p.x === x && p.y === y)) {
                selection.push(pos);
                const cell = document.querySelector(`[data-x="${x}"][data-y="${y}"]`);
                cell.classList.add('selected');
            }
        }

        // Limpiar selección visual
        function clearSelection() {
            document.querySelectorAll('.cell').forEach(cell => {
                cell.classList.remove('selected');
            });
            selection = [];
        }

        // Validar si la selección forma una palabra
        function validateSelection() {
            if (selection.length < 4) return; // Palabras mínimas

            // Ordenar selección por dirección (aproximada)
            const sorted = sortSelectionByDirection();
            const word = sorted.map(pos => grid[pos.y][pos.x]).join('').toUpperCase();

            if (WORDS.includes(word) && !foundWords.has(word)) {
                foundWords.add(word);
                renderWords();
                highlightWord(word);
                messageEl.textContent = `¡Encontraste "${word}"!`;
                setTimeout(() => { messageEl.textContent = ''; }, 2000);
            }
        }

        // Ordenar selección asumiendo dirección lineal (heurística simple)
        function sortSelectionByDirection() {
            if (selection.length <= 1) return selection;
            const first = selection[0];
            const last = selection[selection.length - 1];
            const dx = last.x - first.x;
            const dy = last.y - first.y;
            return [...selection].sort((a, b) => {
                const distA = (a.x - first.x) * dx + (a.y - first.y) * dy;
                const distB = (b.x - first.x) * dx + (b.y - first.y) * dy;
                return distA - distB;
            });
        }

        // Resaltar palabra encontrada
        function highlightWord(word) {
            wordPositions[word].forEach(pos => {
                const cell = document.querySelector(`[data-x="${pos.x}"][data-y="${pos.y}"]`);
                cell.classList.add('part-of-word');
            });
        }

        // Dar pista: revelar una palabra no encontrada
        function giveHint() {
            const unfound = WORDS.filter(w => !foundWords.has(w));
            if (unfound.length === 0) {
                messageEl.textContent = '¡Todas las palabras están encontradas!';
                return;
            }
            const word = unfound[Math.floor(Math.random() * unfound.length)];
            highlightWord(word);
            foundWords.add(word);
            renderWords();
            messageEl.textContent = `Pista: Revelada "${word}"`;
            setTimeout(() => { messageEl.textContent = ''; }, 2000);
        }

        // Rendirse: mostrar todas las palabras
        function giveUp() {
            WORDS.forEach(word => {
                if (!foundWords.has(word) && wordPositions[word]) {
                    highlightWord(word);
                    foundWords.add(word);
                }
            });
            renderWords();
            messageEl.textContent = '¡Solución completa mostrada!';
        }

        // Inicializar al cargar
        init();
    </script>
</body>
</html>
